# CS76, Fall 2021, Assignment 4, Tracey Mills
## Description
I created a general ConstraintSatisfactionClass on which a BacktrackingSolver could be run. The general CSP stores variables and values in terms of integers, with specific csp problems, such as map-coloring or circuit layout, storing mappings from their variables and values to these integers. The assignment checker in the general csp class assumes that constraints are in stored as a dictionary, with variable pairs as keys, and the allowed values for each pair as values.  
The CircuitLayoutProblem class and MapColoring class both have csp objects as instance variables, and the back tracking search is done on these objects. In these classes, domains and constraints are translated into integers before being passed to the csp object, and the resulting assignment is then translated back into the problem's terms in a print_result function.  
BacktrackingSearch.py has global boolean variables which can be set at the top of the file to determine which heuristics are used.  

## Evaluation
The Australia map coloring problem is solved quickly, with heuristics making little difference. This is explained in detail in the discussion section below.  
The circuit board problem given in the assignment is also solved quickly, with both the naive and heuristic approaches. I also tested larger circuit boards. A 15x10 board took around a minute to solve, and a 20x10 board took 1-2 minutes. Interestingly, only one recursive call was made per component, suggesting that no bakctracking needed to take place. This may be because within each components domain, locations in the board were listed left to right, bottom to top. Thus, even in the naive version, components would be placed as close together as possible, starting at the edge of the board. This is pretty good strategy for placing components, and so backtracking was not necessary. If the domains were randomly ordered instead, we would see more recursive calls and have greater need for the heuristics. Because of this ordering of domains, none of the heurisics reduced the number of calls. However, implementing arc consistency did greatly reduce the sizes of the domains of the variables, especially at the start of the search. This means that many less values could be assigned to each variable, which in general should reduce runtime of the algorithm.  
 

## Discussion
1. In Australia map coloring, only 8 recursive calls are made in the naive version of the algorithm, because the locations are explored such that after the first two assignments, each location (except for tasmania, which is unconstrained) is adjacent to two already assigned locations, so that each location is colored correctly the first time and no backtracking is necessary. Thus, the heuristics do not change the run time much. MRV causes no change, since there tends to be ties in terms of number of remaining values for each unassigned variable. The degree does not change the number of calls, but does change the colors assigned to the locations, because the order of locations explored changes. This would have a greater impact on the speed of the algorithm for larger maps with many nonadjacent locations. LCV similarly does not impact the runtime. It does not affect the output at all, because adjacent locations tend to be explored back to back, and so there is often only one legal value for the color assignment. Finally, while arc consistency does not change the number of calls, it does decrease the size of the domains of each variable much more rapidly than the naive approach does, since inconsistent values are removed from domains after each assignment.
2. In the circuit layout problem, the domain of a component was the set of all x,y locations of the bottom left of the component such that the entire component fit in the circuit board. To calculate the domain of a component of width w and height h, on a circuit board of width n and height m, I found every possible y value for the component as 0 through m-h+1, and every possible x value for the component as 0 through n-w+1. I then took every combination of these x,y values and added that location to the domain.
3. I stored constraints as lists for each pair of components containing the allowable values for that pair. These are all values in the domains of the components which do not have the components overlapping. I calculated this by iterating through the domains of each pair of components and comparing their max and min x and y values, selecting those value pairs where no overlap occured. The constraint for components a,b as given in the example is [(5, 0), (6, 0), (7, 0), (15, 0), (16, 0), (17, 0), (6, 1), (7, 1), (16, 1), (17, 1), (7, 2), (17, 2), (0, 3), (10, 3), (0, 4), (1, 4), (10, 4), (11, 4), (0, 5), (1, 5), (2, 5), (10, 5), (11, 5), (12, 5), (5, 10), (6, 10), (7, 10), (15, 10), (16, 10), (17, 10), (6, 11), (7, 11), (16, 11), (17, 11), (7, 12), (17, 12), (0, 13), (10, 13), (0, 14), (1, 14), (10, 14), (11, 14), (0, 15), (1, 15), (2, 15), (10, 15), (11, 15), (12, 15)], where integers are linearized x,y locations (y*(numCols in component) + x).
4. My code converts constraints to integer values as described above - x,y locations, the values in this csp, are linearized as (y*(numCols in component) + x). Domains are calculated in the same way. I converted components into integers by simply keeping the list of components as a class variable, and then letting the index of each component in the list be its integer mapping for use in the general csp.  

## Bonus
I found the idea of flipped solutions in the circuit board interesting, and implemented a version of the CircuitLayoutProblem that took advantage of this. Since solutions can be flipped horizontally, vertically, or both, each solution is representative of up to 4 possible solutions. I used this fact to reduce the domain size of a component prior to starting the search. For a given location l, call the horixontal flip of l over the midline of the circuit board l', the vertical flip of l l'', and the horizontal and vertical flip of l l'''. For the component with the largest domain, for each location l in its domain, I removed l', l'', and l''' if they were different from l. In this way, the domain size of this component is reduced by up to 75%. This decreased domain size speeds up the backtracking search algorithm since less values can be considered for that variable.
